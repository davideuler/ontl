/**\file*********************************************************************
 *                                                                     \brief
 *  Device Object
 *
 ****************************************************************************
 */
#ifndef NTL__KM_DEVICE_OBJECT
#define NTL__KM_DEVICE_OBJECT
#pragma once

#include "object.hxx"
#include "irp.hxx"
#include "event.hxx"
#include "dpc.hxx"

namespace ntl {
namespace km {

NTL_EXTERNAPI
ntstatus __stdcall
  IoCreateDevice(
    driver_object* DriverObject,
    uint32_t DeviceExtensionSize,
    const const_unicode_string& DeviceName,
    uint32_t DeviceType,
    uint32_t DeviceCharacteristics,
    bool Exclusive,
    device_object** DeviceObject
    );

NTL_EXTERNAPI
ntstatus __stdcall
  IoDeleteDevice(device_object* DeviceObject);


NTL_EXTERNAPI
ntstatus __stdcall
  IoCreateSymbolicLink(
    const const_unicode_string& SymbolicLinkName,
    const const_unicode_string& DeviceName
    );

NTL_EXTERNAPI
ntstatus __stdcall
  IoDeleteSymbolicLink(const const_unicode_string& SymbolicLinkName);

NTL_EXTERNAPI
ntstatus __stdcall
  IoEnumerateDeviceObjectList(
    const driver_object*  DriverObject,
    device_object** DeviceObjectList,
    uint32_t DeviceObjectListSize,
    uint32_t* ActualNumberDeviceObjects
    );


struct devobj_extension
{
  uint16_t        Type;
  uint16_t        Size;
  device_object * DeviceObject;
  uint32_t        PowerFlags;
  struct device_object_power_extension* Dope;
  uint32_t        ExtensionFlags;
  void *          DeviceNode;
  device_object * AttachedTo;
  int32_t         StartIoCount;
  int32_t         StartIoKey;
  uint32_t        StartIoFlags;
  vpb *           Vpb;
};


struct device_object
{
  struct io_type
  {
    enum type {
      adapter,
      controller,
      device,
      driver,
      file,
      irp,
      master_adapter,
      open_packet,
      timer,
      vpb,
      error_log,
      error_message,
      device_object_extension
    };
  };
  enum type {
    beep = 1,
    cd_rom,
    cd_rom_file_system,
    controller,
    datalink,
    dfs,
    disk,
    disk_file_system,
    file_system,
    inport_port,
    keyboard,
    mailslot,
    midi_in,
    midi_out,
    mouse,
    multi_unc_provider,
    named_pipe,
    network,
    network_browser,
    network_file_system,
    null,
    parallel_port,
    physical_netcard,
    printer,
    scanner,
    serial_mouse_port,
    serial_port,
    screen,
    sound,
    streams,
    tape,
    tape_file_system,
    transport,
    unknown,
    video,
    virtual_disk,
    wave_in,
    wave_out,
    _8042_port,
    network_redirector,
    battery,
    bus_extender,
    modem,
    vdm,
    mass_storage,
    smb,
    ks,
    changer,
    smartcard,
    acpi,
    dvd,
    fullscreen_video,
    dfs_file_system,
    dfs_volume,
    serenum,
    termsrv,
    ksec,
    fips,
    infiniband,
  };
  STATIC_ASSERT(infiniband == 0x3B);

  struct flags { enum type {
    none,
    do_verify_volume                = 0x00000002,
    do_buffered_io                  = 0x00000004,
    do_exclusive                    = 0x00000008,
    do_direct_io                    = 0x00000010,
    do_map_io_buffer                = 0x00000020,
    do_device_has_name              = 0x00000040,
    do_device_initializing          = 0x00000080,
    do_system_boot_partition        = 0x00000100,
    do_long_term_requests           = 0x00000200,
    do_never_last_device            = 0x00000400,
    do_shutdown_registered          = 0x00000800,
    do_bus_enumerated_device        = 0x00001000,
    do_power_pagable                = 0x00002000,
    do_power_inrush                 = 0x00004000,
    do_power_noop                   = 0x00008000,
    do_low_priority_filesystem      = 0x00010000,
    do_xip                          = 0x00020000
   };
  };

  struct characteristics { enum type {
    none,
    removable_media            = 0x00000001,
    read_only_device           = 0x00000002,
    floppy_diskette            = 0x00000004,
    write_once_media           = 0x00000008,
    remote_device              = 0x00000010,
    device_is_mounted          = 0x00000020,
    virtual_volume             = 0x00000040,
    autogenerated_device_name  = 0x00000080,
    device_secure_open         = 0x00000100,
    pnp_device                 = 0x00000800,

    // NOTE: winxp only?
    expect_orderly_removal     = 0x00000200,
    expect_surprise_removal    = 0x00000300,
    removal_policy_mask        = 0x00000300,
   };
    static const type propagated = static_cast<type>(removable_media|read_only_device|floppy_diskette|write_once_media|device_secure_open);
  };

  const uint16_t        Type;               // io_type
  const uint16_t        Size;
  const int32_t         ReferenceCount;
  driver_object * const DriverObject;
  device_object *       NextDevice;
  device_object *       AttachedDevice;
  struct irp    * const CurrentIrp;
  io_timer *            Timer;
  flags::type           Flags;
  characteristics::type Characteristics;
  vpb *                 Vpb;
  void * const          DeviceExtension;
  type                  DeviceType;         // type
  uint8_t               StackSize;
  union { list_entry ListEntry; wait_context_block  Wcb; } Queue;
  uint32_t              AlignmentRequirement;
  kdevice_queue         DeviceQueue;
  kdpc                  Dpc;
  uint32_t              ActiveThreadCount;
  security_descriptor * const SecurityDescriptor;
  kevent                DeviceLock;
  uint16_t              SectorSize;
  uint16_t              Spare1;
  devobj_extension *    DeviceObjectExtension;
  void *                Reserved;

  typedef ntstatus __stdcall dispatch_t(device_object *, irp *);
  typedef dispatch_t *  dispatch_ptr;

  device_object * get_attached_device()
  {
    device_object * pdo = this;
    while ( pdo->AttachedDevice ) pdo = pdo->AttachedDevice;
    return pdo;
  }

  device_object * get_root_device()
  {
    device_object * pdo = this;
    while ( pdo->DeviceObjectExtension && pdo->DeviceObjectExtension->AttachedTo )
      pdo = pdo->DeviceObjectExtension->AttachedTo;
    return pdo;
  }

  static __forceinline
  device_object *
    get_by_name(
      const const_unicode_string & object_name,
      const access_mask            desired_access)
  {
    device_object * pdo = nullptr;
    file_object *   pfo = nullptr;
    IoGetDeviceObjectPointer(&object_name, desired_access, &pfo, &pdo);
    ObfDereferenceObject(pfo);
    return pdo;
  }

  ntstatus call(irp * pirp);

private:
  device_object();
  device_object(const device_object&);
  device_object& operator=(const device_object&);

}; // struct device_object

__ntl_bitmask_type(device_object::flags::type, inline);
__ntl_bitmask_type(device_object::characteristics::type, inline);

typedef device_object::type device_type;


}//namspace km
}//namespace ntl


#endif//#ifndef NTL__KM_DEVICE_OBJECT
