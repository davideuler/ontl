/**\file*********************************************************************
 *                                                                     \brief
 *  20.6 Function objects [function.objects]
 *
 ****************************************************************************
 */
#ifndef NTL__STLX_BIND
#define NTL__STLX_BIND

#include "result_of.hxx"
#include "placeholders.hxx"
#include "tuple.hxx"
#include "fn_caller.hxx"

namespace std
{
/**\addtogroup  lib_utilities ********** 20 General utilities library [utilities]
 *@{

/**\addtogroup  lib_function_objects ***** 20.6 Function objects [function.objects]
 *@{*/

/**\defgroup  lib_bind ***************** 20.6.11 Function template bind [bind]
 *  
 *  The function template bind returns an object that binds a function object passed as an argument to additional arguments.
 *  Binders bind1st and bind2nd take a function object \c fn of two arguments and a value \c x and return a function
 *  object of one argument constructed out of \c fn with the first or second argument correspondingly bound to \c x.
 *@{*/

  /**
   *	@brief 20.6.11.1.1 Class template is_bind_expression [func.bind.isbind]
   *
   *  is_bind_expression can be used to detect function objects generated by bind. bind uses is_bind_expression to detect subexpressions. 
   *  Users may specialize this template to indicate that a type should be treated as a subexpression in a bind call.
   **/
  template<class T> 
  struct is_bind_expression: false_type {};

  namespace __
  {
    using ttl::meta::empty_type;

    namespace binds
    {
      namespace tl = ntl::meta::tl;
      using ntl::meta::tlist;

      template<size_t i> struct flag : integral_constant<int, i>{};

      template<class Bunch, class Args>
      struct bindargs
      {
      private:
        static const size_t BunchSize = tuple_size<Bunch>::value, ArgsSize = tuple_size<Args>::value;

        template<size_t I> struct get_arg_type   { typedef typename tuple_element<I,Args >::type type; };
        template<size_t I> struct get_bound_type { typedef typename tuple_element<I,Bunch>::type type; };

        template<size_t I, bool,bool> struct argsel
        {
          typedef typename get_bound_type<I>::type B;
          static const int N = is_placeholder<B>::value;
          static_assert(N == 0 || (N-1 < static_cast<int>(ArgsSize)), "Placeholder's index_type is out of bounds.");
          typedef typename conditional<(N > 0), get_arg_type<N-1>, get_bound_type<I> >::type weak_type;
          typedef typename weak_type::type type;
        };
        template<size_t I> struct argsel<I,false,true>
        {
          static const int N = 0;
          typedef typename get_arg_type<I-BunchSize>::type type;
        };
        template<size_t I> struct argsel<I,false,false>
        {
          static const int N = -1;
          typedef ttl::meta::empty_type type;
        };
        template<size_t I> struct argtype
        {
          typedef argsel<I,(I < BunchSize),(I < ArgsSize)> arg;
          typedef typename arg::type type;
          static const int N = arg::N;
        };

        template<size_t I, class T> struct argtype_handler
        {
          static const bool stop = false;
          typedef typename argtype<I>::type type;
        };
        typedef typename tup2tl<argtype_handler, typename Bunch::types>::result bound_types;
      protected:
        template<typename R, size_t I, int N>
        static R arg(const Bunch&, const Args& args, index_type<N>)
        {
          return field2<R,N-1>::get(args);
        }
        template<typename R, size_t I>
        static R arg(const Bunch& bunch, const Args&, index_type<0>)
        {
          return field2<R,I>::get(bunch);
        }
        template<typename R, size_t I>
        static R arg(const Bunch&, const Args&, index_type<-1>)
        {
          return empty_type();
        }
        template<size_t I>
        static typename argtype<I>::type get(const Bunch& b, const Args& a)
        {
          typedef typename argtype<I>::type R;
          return arg<typename argtype<I>::type,I>(b,a,index_type<argtype<I>::N>());
        }
      public:
        typedef typename tl2tup<bound_types>::type tuple_type;

        static tuple_type result(const Bunch& b, const Args& a)
        {
          return tuple_type(get<0>(b,a), get<1>(b,a), get<2>(b,a), get<3>(b,a), get<4>(b,a));
        }
      };
    } // binds

    template<typename Result, class F, class BunchArgs, bool relaxed = false>
    struct bind_t
    {
      template<class A1 = empty_type, class A2 = empty_type> struct R
      {
        typedef FUNARGS(A1,A2) Args;
        typedef typename conditional<relaxed, type2type<Result>, result_of_impl<F> >::type weak_type;
        typedef typename weak_type::type type;
      };

    public:
      bind_t(F f, const BunchArgs& args)
        :f(f), bunch(args)
      {}

      typename R<>::type operator()() const
      {
        typedef R<> R;
        typedef typename R::Args Args;
        typedef binds::bindargs<BunchArgs, Args> bindargs;
        return func::invoke<typename R::type>(f,bindargs::result(bunch,Args()));
      }
      template<class A1>
      typename R<A1>::type  operator()(A1 a1) const
      {
        typedef R<A1> R;
        typedef typename R::Args Args;
        typedef binds::bindargs<BunchArgs, Args> bindargs;
        return func::invoke<typename R::type>(f,bindargs::result(bunch,Args(a1)));
      }
      template<class A1, class A2>
      typename R<A1,A2>::type  operator()(A1 a1, A2 a2) const
      {
        typedef R<A1,A2> R;
        typedef typename R::Args Args;
        typedef binds::bindargs<BunchArgs, Args> bindargs;
        return func::invoke<typename R::type>(f,bindargs::result(bunch,Args(a1,a2)));
      }
    private:
      F f;
      BunchArgs bunch; // связанные параметры (вместе с метками)
    };

    template<class F, class A1 = empty_type, class A2 = empty_type>
    struct binder
    {typedef bind_t<empty_type, F, FUNARGS(A1,A2)> type; };
    template<typename R, class F, class A1 = empty_type, class A2 = empty_type>
    struct nbinder
    {typedef bind_t<R, F, FUNARGS(A1,A2), true> type; };
  } // __

  template<typename R, class F, class Args, bool relaxed>
  struct is_bind_expression<__::bind_t<R,F,Args,relaxed> >: true_type {};

  // no arguments
  template<class F>
  typename __::binder<F>::type bind(F f)
  {
    return typename __::binder<F>::type(f, FUNARGS()());
  }

  // 1 argument
  template<class F, class A1>
  typename __::binder<F, A1>::type bind(F f, A1 a1)
  {
    return typename __::binder<F, A1>::type(f, FUNARGS(A1)(a1));
  }

  // 2 arguments
  template<class F, class A1, class A2>
  typename __::binder<F, A1,A2>::type bind(F f, A1 a1, A2 a2)
  {
    return typename __::binder<F, A1,A2>::type(f, FUNARGS(A1,A2)(a1,a2));
  }

  // non-strict bind()

  // no arguments
  template<typename R, class F>
  typename __::nbinder<R,F>::type bind(F f)
  {
    return typename __::nbinder<R,F>::type(f, FUNARGS()());
  }

  // 1 argument
  template<typename R, class F, class A1>
  typename __::nbinder<R,F, A1>::type bind(F f, A1 a1)
  {
    return typename __::nbinder<R,F, A1>::type(f, FUNARGS(A1)(a1));
  }

  // 2 arguments
  template<typename R, class F, class A1, class A2>
  typename __::nbinder<R,F, A1,A2>::type bind(F f, A1 a1, A2 a2)
  {
    return typename __::nbinder<R,F, A1,A2>::type(f, FUNARGS(A1,A2)(a1,a2));
  }

  /**@} lib_bind */
  /**@} lib_function_objects */
  /**@} lib_utilities */
} // std
#endif // NTL__STLX_BIND
